# Complete React Redux State Management Guide

## Table of Contents

1. [Introduction to Redux](#1.-introduction-to-redux)
2. [Core Concepts](#2.-core-concepts)
3. [Redux Toolkit (RTK) - Modern Redux](#3.-redux-toolkit-(rtk)---modern-redux)
4. [Setting Up Redux in React](#4.-setting-up-redux-in-react)
5. [Actions and Action Creators](#5.-actions-and-action-creators)
6. [Reducers](#6.-reducers)
7. [Store Configuration](#7.-store-configuration)
8. [React-Redux Hooks](#8.-react-redux-hooks)
9. [Async Operations with Redux Toolkit Query](#9.-async-operations-with-redux-toolkit-query)
10. [Middleware](#10.-middleware)
11. [Best Practices](#11.-best-practices)
12. [Complete Example](#12.-complete-example)

---

## 1. Introduction to Redux

### Definition
Redux is a predictable state container for JavaScript applications. It helps manage application state in a centralized store, making state mutations predictable through pure functions called reducers.

### Key Benefits
- **Predictable State Updates**: State changes are pure and predictable
- **Centralized State**: Single source of truth for application state
- **Time Travel Debugging**: Can replay actions and see state changes
- **Hot Reloading**: Preserve state during development
- **Server-Side Rendering**: Easily serialize and hydrate state

### When to Use Redux
- Large applications with complex state logic
- State needs to be shared across many components
- State updates frequently over time
- Logic to update state is complex
- Medium to large codebase with many developers

---

## 2. Core Concepts

### 2.1 Store
**Definition**: The single source of truth that holds the complete state tree of your application.

### 2.2 Actions
**Definition**: Plain JavaScript objects that describe what happened. They must have a `type` property.

### 2.3 Reducers
**Definition**: Pure functions that specify how the application's state changes in response to actions.

### 2.4 Dispatch
**Definition**: The only way to trigger a state change by sending an action to the store.

### 2.5 Selectors
**Definition**: Functions that extract specific pieces of data from the store state.

---

## 3. Redux Toolkit (RTK) - Modern Redux

### Definition
Redux Toolkit is the official, opinionated, batteries-included toolset for efficient Redux development. It simplifies Redux usage and includes utilities to simplify common use cases.

### Key Features
- **configureStore()**: Simplified store setup
- **createSlice()**: Generates action creators and reducers
- **createAsyncThunk()**: Handles async logic
- **RTK Query**: Data fetching and caching solution

### Installation
```bash
npm install @reduxjs/toolkit react-redux
```

---

## 4. Setting Up Redux in React

### 4.1 Basic Setup Structure
```
src/
├── store/
│   ├── index.js          # Store configuration
│   ├── counterSlice.js   # Feature slice
│   └── userSlice.js      # Another feature slice
├── components/
│   └── Counter.js        # React component
└── App.js               # Root component
```

### 4.2 Provider Setup
```jsx
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import { store } from './store';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

---

## 5. Actions and Action Creators

### 5.1 Traditional Actions (Legacy)
```javascript
// Action Types
const INCREMENT = 'counter/increment';
const DECREMENT = 'counter/decrement';

// Action Creators
const increment = () => ({
  type: INCREMENT
});

const decrement = () => ({
  type: DECREMENT
});

const incrementByAmount = (amount) => ({
  type: 'counter/incrementByAmount',
  payload: amount
});
```

### 5.2 RTK Actions (Modern Approach)
```javascript
// Actions are automatically generated by createSlice
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1; // RTK uses Immer internally
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    }
  }
});

// Actions are automatically generated
export const { increment, decrement, incrementByAmount } = counterSlice.actions;
```

---

## 6. Reducers

### 6.1 Traditional Reducers (Legacy)
```javascript
const initialState = {
  value: 0
};

function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'counter/increment':
      return {
        ...state,
        value: state.value + 1
      };
    case 'counter/decrement':
      return {
        ...state,
        value: state.value - 1
      };
    case 'counter/incrementByAmount':
      return {
        ...state,
        value: state.value + action.payload
      };
    default:
      return state;
  }
}
```

### 6.2 RTK Slice Reducers (Modern)
```javascript
// src/store/counterSlice.js
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0,
    status: 'idle'
  },
  reducers: {
    increment: (state) => {
      // RTK uses Immer, so we can "mutate" the state
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    },
    reset: (state) => {
      state.value = 0;
      state.status = 'idle';
    }
  }
});

export const { increment, decrement, incrementByAmount, reset } = counterSlice.actions;
export default counterSlice.reducer;
```

---

## 7. Store Configuration

### 7.1 RTK Store Setup
```javascript
// src/store/index.js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';
import userReducer from './userSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer,
    user: userReducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST']
      }
    }),
  devTools: process.env.NODE_ENV !== 'production'
});

// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

### 7.2 Multiple Slices Example
```javascript
// src/store/userSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Async thunk for fetching user
export const fetchUser = createAsyncThunk(
  'user/fetchUser',
  async (userId) => {
    const response = await fetch(`/api/users/${userId}`);
    return response.json();
  }
);

const userSlice = createSlice({
  name: 'user',
  initialState: {
    data: null,
    loading: false,
    error: null
  },
  reducers: {
    clearUser: (state) => {
      state.data = null;
      state.error = null;
    },
    updateProfile: (state, action) => {
      if (state.data) {
        state.data = { ...state.data, ...action.payload };
      }
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUser.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(fetchUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  }
});

export const { clearUser, updateProfile } = userSlice.actions;
export default userSlice.reducer;
```

---

## 8. React-Redux Hooks

### 8.1 useSelector Hook
**Definition**: Extracts data from the Redux store state using a selector function.

```javascript
import React from 'react';
import { useSelector } from 'react-redux';

const Counter = () => {
  // Basic selector
  const count = useSelector(state => state.counter.value);
  
  // Complex selector with multiple values
  const { value, status } = useSelector(state => ({
    value: state.counter.value,
    status: state.counter.status
  }));
  
  // Selector with computation
  const isPositive = useSelector(state => state.counter.value > 0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <p>Status: {status}</p>
      <p>Is Positive: {isPositive ? 'Yes' : 'No'}</p>
    </div>
  );
};
```

### 8.2 useDispatch Hook
**Definition**: Returns a reference to the dispatch function from the Redux store.

```javascript
import React from 'react';
import { useDispatch } from 'react-redux';
import { increment, decrement, incrementByAmount } from '../store/counterSlice';

const CounterControls = () => {
  const dispatch = useDispatch();
  
  const handleIncrement = () => {
    dispatch(increment());
  };
  
  const handleDecrement = () => {
    dispatch(decrement());
  };
  
  const handleIncrementByFive = () => {
    dispatch(incrementByAmount(5));
  };
  
  return (
    <div>
      <button onClick={handleIncrement}>+</button>
      <button onClick={handleDecrement}>-</button>
      <button onClick={handleIncrementByFive}>+5</button>
    </div>
  );
};
```

### 8.3 Custom Hooks
```javascript
// src/hooks/useCounter.js
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement, incrementByAmount, reset } from '../store/counterSlice';

export const useCounter = () => {
  const { value, status } = useSelector(state => state.counter);
  const dispatch = useDispatch();
  
  return {
    count: value,
    status,
    increment: () => dispatch(increment()),
    decrement: () => dispatch(decrement()),
    incrementByAmount: (amount) => dispatch(incrementByAmount(amount)),
    reset: () => dispatch(reset())
  };
};

// Usage in component
const Counter = () => {
  const { count, increment, decrement, reset } = useCounter();
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
};
```

---

## 9. Async Operations with Redux Toolkit Query

### 9.1 createAsyncThunk
```javascript
// src/store/postsSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Async thunk
export const fetchPosts = createAsyncThunk(
  'posts/fetchPosts',
  async (_, { rejectWithValue }) => {
    try {
      const response = await fetch('/api/posts');
      if (!response.ok) {
        throw new Error('Failed to fetch posts');
      }
      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const createPost = createAsyncThunk(
  'posts/createPost',
  async (postData, { rejectWithValue }) => {
    try {
      const response = await fetch('/api/posts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(postData)
      });
      return await response.json();
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const postsSlice = createSlice({
  name: 'posts',
  initialState: {
    items: [],
    loading: false,
    error: null
  },
  reducers: {
    clearError: (state) => {
      state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      // Fetch posts
      .addCase(fetchPosts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      // Create post
      .addCase(createPost.fulfilled, (state, action) => {
        state.items.push(action.payload);
      });
  }
});

export default postsSlice.reducer;
```

### 9.2 RTK Query (Advanced Data Fetching)
```javascript
// src/store/api.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api/',
    prepareHeaders: (headers, { getState }) => {
      const token = getState().auth.token;
      if (token) {
        headers.set('authorization', `Bearer ${token}`);
      }
      return headers;
    }
  }),
  tagTypes: ['Post', 'User'],
  endpoints: (builder) => ({
    getPosts: builder.query({
      query: () => 'posts',
      providesTags: ['Post']
    }),
    getPost: builder.query({
      query: (id) => `posts/${id}`,
      providesTags: (result, error, id) => [{ type: 'Post', id }]
    }),
    createPost: builder.mutation({
      query: (newPost) => ({
        url: 'posts',
        method: 'POST',
        body: newPost
      }),
      invalidatesTags: ['Post']
    }),
    updatePost: builder.mutation({
      query: ({ id, ...patch }) => ({
        url: `posts/${id}`,
        method: 'PATCH',
        body: patch
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'Post', id }]
    })
  })
});

export const {
  useGetPostsQuery,
  useGetPostQuery,
  useCreatePostMutation,
  useUpdatePostMutation
} = api;
```

---

## 10. Middleware

### 10.1 Custom Middleware
```javascript
// src/store/middleware.js
const loggerMiddleware = (store) => (next) => (action) => {
  console.log('Dispatching:', action);
  const result = next(action);
  console.log('Next state:', store.getState());
  return result;
};

// Usage in store
import { configureStore } from '@reduxjs/toolkit';

export const store = configureStore({
  reducer: {
    counter: counterReducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(loggerMiddleware)
});
```

### 10.2 Popular Middleware
```javascript
import { configureStore } from '@reduxjs/toolkit';
import { persistStore, persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage';

const persistConfig = {
  key: 'root',
  storage,
  whitelist: ['user', 'settings'] // Only persist these reducers
};

const persistedReducer = persistReducer(persistConfig, rootReducer);

export const store = configureStore({
  reducer: persistedReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE']
      }
    })
});

export const persistor = persistStore(store);
```

---

## 11. Best Practices

### 11.1 Structuring State
```javascript
// Good: Normalized state shape
const initialState = {
  posts: {
    byId: {},
    allIds: [],
    loading: false,
    error: null
  },
  users: {
    byId: {},
    allIds: [],
    currentUserId: null
  },
  ui: {
    selectedPostId: null,
    sidebarOpen: false
  }
};

// Bad: Nested/denormalized state
const badState = {
  posts: [
    {
      id: 1,
      title: 'Post 1',
      author: {
        id: 1,
        name: 'John',
        posts: [/* circular reference */]
      }
    }
  ]
};
```

### 11.2 Selector Patterns
```javascript
// src/store/selectors.js
import { createSelector } from '@reduxjs/toolkit';

// Basic selectors
export const selectPosts = (state) => state.posts.byId;
export const selectPostIds = (state) => state.posts.allIds;
export const selectPostsLoading = (state) => state.posts.loading;

// Memoized selectors
export const selectAllPosts = createSelector(
  [selectPosts, selectPostIds],
  (postsById, postIds) => postIds.map(id => postsById[id])
);

export const selectPostById = createSelector(
  [selectPosts, (state, postId) => postId],
  (posts, postId) => posts[postId]
);

export const selectPublishedPosts = createSelector(
  [selectAllPosts],
  (posts) => posts.filter(post => post.published)
);
```

### 11.3 Error Handling
```javascript
const userSlice = createSlice({
  name: 'user',
  initialState: {
    data: null,
    loading: false,
    error: null,
    lastFetch: null
  },
  reducers: {
    clearError: (state) => {
      state.error = null;
    },
    retryFailed: (state) => {
      state.error = null;
      state.loading = true;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUser.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
        state.lastFetch = Date.now();
      })
      .addCase(fetchUser.rejected, (state, action) => {
        state.loading = false;
        state.error = {
          message: action.error.message,
          code: action.error.code,
          timestamp: Date.now()
        };
      });
  }
});
```

---

## 12. Complete Example

### 12.1 Todo Application
```javascript
// src/store/todoSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

export const fetchTodos = createAsyncThunk(
  'todos/fetchTodos',
  async () => {
    const response = await fetch('/api/todos');
    return response.json();
  }
);

const todoSlice = createSlice({
  name: 'todos',
  initialState: {
    items: [],
    loading: false,
    error: null,
    filter: 'all' // all, active, completed
  },
  reducers: {
    addTodo: (state, action) => {
      const newTodo = {
        id: Date.now(),
        text: action.payload,
        completed: false,
        createdAt: new Date().toISOString()
      };
      state.items.push(newTodo);
    },
    toggleTodo: (state, action) => {
      const todo = state.items.find(todo => todo.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    deleteTodo: (state, action) => {
      state.items = state.items.filter(todo => todo.id !== action.payload);
    },
    editTodo: (state, action) => {
      const { id, text } = action.payload;
      const todo = state.items.find(todo => todo.id === id);
      if (todo) {
        todo.text = text;
      }
    },
    setFilter: (state, action) => {
      state.filter = action.payload;
    },
    clearCompleted: (state) => {
      state.items = state.items.filter(todo => !todo.completed);
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTodos.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchTodos.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  }
});

export const {
  addTodo,
  toggleTodo,
  deleteTodo,
  editTodo,
  setFilter,
  clearCompleted
} = todoSlice.actions;

export default todoSlice.reducer;

// Selectors
export const selectAllTodos = (state) => state.todos.items;
export const selectTodosLoading = (state) => state.todos.loading;
export const selectTodosError = (state) => state.todos.error;
export const selectFilter = (state) => state.todos.filter;

export const selectFilteredTodos = (state) => {
  const todos = selectAllTodos(state);
  const filter = selectFilter(state);
  
  switch (filter) {
    case 'active':
      return todos.filter(todo => !todo.completed);
    case 'completed':
      return todos.filter(todo => todo.completed);
    default:
      return todos;
  }
};

export const selectTodoStats = (state) => {
  const todos = selectAllTodos(state);
  return {
    total: todos.length,
    completed: todos.filter(todo => todo.completed).length,
    active: todos.filter(todo => !todo.completed).length
  };
};
```

### 12.2 Todo Component
```javascript
// src/components/TodoApp.js
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  fetchTodos,
  addTodo,
  toggleTodo,
  deleteTodo,
  editTodo,
  setFilter,
  clearCompleted,
  selectFilteredTodos,
  selectTodoStats,
  selectTodosLoading,
  selectFilter
} from '../store/todoSlice';

const TodoApp = () => {
  const [newTodoText, setNewTodoText] = useState('');
  const [editingId, setEditingId] = useState(null);
  const [editText, setEditText] = useState('');
  
  const dispatch = useDispatch();
  const todos = useSelector(selectFilteredTodos);
  const stats = useSelector(selectTodoStats);
  const loading = useSelector(selectTodosLoading);
  const filter = useSelector(selectFilter);
  
  useEffect(() => {
    dispatch(fetchTodos());
  }, [dispatch]);
  
  const handleAddTodo = (e) => {
    e.preventDefault();
    if (newTodoText.trim()) {
      dispatch(addTodo(newTodoText.trim()));
      setNewTodoText('');
    }
  };
  
  const handleEditStart = (todo) => {
    setEditingId(todo.id);
    setEditText(todo.text);
  };
  
  const handleEditSave = (id) => {
    if (editText.trim()) {
      dispatch(editTodo({ id, text: editText.trim() }));
    }
    setEditingId(null);
    setEditText('');
  };
  
  const handleEditCancel = () => {
    setEditingId(null);
    setEditText('');
  };
  
  if (loading) return <div>Loading todos...</div>;
  
  return (
    <div className="todo-app">
      <h1>Todo App</h1>
      
      {/* Add Todo Form */}
      <form onSubmit={handleAddTodo}>
        <input
          type="text"
          value={newTodoText}
          onChange={(e) => setNewTodoText(e.target.value)}
          placeholder="Add a new todo..."
        />
        <button type="submit">Add</button>
      </form>
      
      {/* Stats */}
      <div className="stats">
        <span>Total: {stats.total}</span>
        <span>Active: {stats.active}</span>
        <span>Completed: {stats.completed}</span>
      </div>
      
      {/* Filters */}
      <div className="filters">
        {['all', 'active', 'completed'].map(filterType => (
          <button
            key={filterType}
            onClick={() => dispatch(setFilter(filterType))}
            className={filter === filterType ? 'active' : ''}
          >
            {filterType.charAt(0).toUpperCase() + filterType.slice(1)}
          </button>
        ))}
      </div>
      
      {/* Todo List */}
      <ul className="todo-list">
        {todos.map(todo => (
          <li key={todo.id} className={todo.completed ? 'completed' : ''}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => dispatch(toggleTodo(todo.id))}
            />
            
            {editingId === todo.id ? (
              <div className="edit-form">
                <input
                  type="text"
                  value={editText}
                  onChange={(e) => setEditText(e.target.value)}
                  onKeyPress={(e) => {
                    if (e.key === 'Enter') handleEditSave(todo.id);
                    if (e.key === 'Escape') handleEditCancel();
                  }}
                  autoFocus
                />
                <button onClick={() => handleEditSave(todo.id)}>Save</button>
                <button onClick={handleEditCancel}>Cancel</button>
              </div>
            ) : (
              <div className="todo-content">
                <span onDoubleClick={() => handleEditStart(todo)}>{todo.text}</span>
                <button onClick={() => handleEditStart(todo)}>Edit</button>
                <button onClick={() => dispatch(deleteTodo(todo.id))}>Delete</button>
              </div>
            )}
          </li>
        ))}
      </ul>
      
      {/* Clear Completed */}
      {stats.completed > 0 && (
        <button onClick={() => dispatch(clearCompleted())}>
          Clear Completed ({stats.completed})
        </button>
      )}
    </div>
  );
};

export default TodoApp;
```

This comprehensive guide covers all essential aspects of React Redux state management, from basic concepts to advanced patterns and real-world examples. The modern Redux Toolkit approach is emphasized throughout, as it's the recommended way to use Redux in new applications.

**[⬆ Back to Top](#table-of-contents)**